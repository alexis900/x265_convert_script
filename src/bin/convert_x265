#!/usr/bin/env bash

# convert_x265: Batch video converter to H265 (HEVC) or container changer
#
# Usage:
#   ./convert_x265 [options]
#
# Options:
#   --help, -h                      Show this help message and exit.
#   --version, -v                   Show script version and exit.
#   --input, -i <file|directory>    Specify the directory to process (overrides actual_dir).
#   --log-level <level>             Set log level (DEBUG, INFO, WARNING, ERROR).
#   --estimate-size <file>          Estimate the size after H265 conversion for a file.
#   --check-xattr <file>            Check if the xattr user.larger is present on a file.
#   --cleanup-temp-files            Clean up temporary files created during processing.
#
# Examples:
#   ./convert_x265 --input /path/to/videos --log-level DEBUG
#   ./convert_x265 --estimate-size /path/to/video.mp4
#
# Requirements:
#   - ffmpeg, ffprobe, bc, grep, cut, stat, wc, numfmt
#   - Configuration in config/preferences.conf
#   - Helper scripts in src/
#
# Author: Alejandro Martín Pérez
# License: MIT License


# Detect if running from a deb package install or from source directory
readonly SCRIPT_PATH=$(realpath "${BASH_SOURCE[0]}")
readonly SCRIPT_DIR=$(dirname "$SCRIPT_PATH")
# If installed system-wide, use the shared path, otherwise assume repo layout
if [[ -d "/usr/local/share/x265_convert_script" && $SCRIPT_DIR == "/usr/local/bin" ]]; then
    readonly SHARE_PATH="/usr/local/share/x265_convert_script"
else
    # script typically lives in src/bin; set SHARE_PATH to project root so
    # paths like $SHARE_PATH/src/lib/... resolve correctly.
    readonly SHARE_PATH="$(dirname "$(dirname "$SCRIPT_DIR")")"
fi

# Compute SRC_PATH (where src/lib, src/config, profiles live) and load prefs
readonly SRC_PATH="$SHARE_PATH/src"
if [[ -f "$SRC_PATH/config/preferences.conf" ]]; then
    source "$SRC_PATH/config/preferences.conf"
else
    echo "Error: preferences.conf not found in $SRC_PATH/config. Exiting..."
    exit 1
fi

# Verify if the required files exist
declare -A required_files=(
    ["logging.sh"]="$SHARE_PATH"
    ["media_utils.sh"]="$SHARE_PATH"
    ["file_utils.sh"]="$SHARE_PATH"
    ["backup.sh"]="$SHARE_PATH"
    ["check_update.sh"]="$SHARE_PATH"
    ["display_help.sh"]="$SHARE_PATH"
    ["arguments.sh"]="$SHARE_PATH"
)

for file in "${!required_files[@]}"; do
    full_path="${required_files[$file]}/src/lib/$file"
    if [[ ! -f "$full_path" ]]; then
        echo "Error: Required file $file does not exist in ${required_files[$file]}. Exiting..."
        echo $full_path
        exit 1
    fi

    if [[ "$file" == *.sh ]]; then
        source "$full_path"
    fi
done


# Function to handle signals
handle_signal() {
    log "INFO" "Signal received, cleaning up and exiting..." "${LOG_FILE}"
    cleanup_temp_files
    exit 1
}

# Register signal handlers
trap handle_signal SIGINT SIGTERM

function find_files () {

    while true; do
        log "INFO" "Searching for files in ${ACTUAL_DIR}..." "${LOG_FILE}"

        files=$(find_pending_files)

        if [[ -z "$files" ]]; then
            log "INFO" "No files found to convert or change container. Exiting..." "${LOG_FILE}"
            break
        fi

        while IFS= read -r file; do
            process_file "$file"
        done <<< "$files"

        log "INFO" "Waiting 10 seconds before the next iteration..." "${LOG_FILE}"
        sleep ${SLEEP_TIME}
    done
}

# Ensure a directory is specified if --input is not used
if [[ -z "${ACTUAL_DIR}" ]]; then
    echo "Error: No directory specified. Use --input to define it."
    exit 1
else
    find_files
fi


# Export LOG_LEVEL for use in logging.sh
export LOG_LEVEL

exit 0
